name: Pack & Publish to GitHub Packages (reusable)

on:
  # Allow other repos to call this workflow
  workflow_call:
    inputs:
      major:
        description: 'Major version for prerelease on develop'
        required: true
        type: string
        default: '9'
      minor:
        description: 'Minor version for prerelease on develop'
        required: true
        type: string
        default: '1'
      mode:
        description: 'changed = only pack changed projects; all = pack everything'
        required: true
        type: string
        default: 'changed'
      pack_glob:
        description: 'Glob for packable projects'
        required: false
        type: string
        default: '**/*.csproj'   # keep generic; callers may override to "*_oM.csproj"
      base:
        description: 'Optional manual base SHA for change detection'
        required: false
        type: string
      head:
        description: 'Optional manual head SHA for change detection'
        required: false
        type: string
      dotnet:
        description: 'SDK version channel'
        required: true
        type: string
        default: '8.0.x'

  # Optional: run it directly in the central repo for debugging/manual checks
  workflow_dispatch:
    inputs:
      major:
        description: 'Major version for prerelease on develop'
        required: true
        default: '9'
      minor:
        description: 'Minor version for prerelease on develop'
        required: true
        default: '1'
      mode:
        description: 'changed = only changed projects; all = everything'
        required: true
        default: 'changed'
      pack_glob:
        description: 'Glob for packable projects'
        required: false
        default: '**/*.csproj'
      base:
        description: 'Optional manual base SHA'
        required: false
      head:
        description: 'Optional manual head SHA'
        required: false
      dotnet:
        description: 'SDK version channel'
        required: true
        default: '8.0.x'

permissions:
  contents: read
  packages: write

jobs:
  pack-and-publish:
    runs-on: ubuntu-latest
    concurrency:
      group: publish-${{ github.repository }}-${{ github.ref }}
      cancel-in-progress: false

    env:
      OWNER: ${{ github.repository_owner }}
      NUGET_SOURCE_URL: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET and auth to GitHub Packages
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ inputs.dotnet || github.event.inputs.dotnet || '8.0.x' }}
          source-url: ${{ env.NUGET_SOURCE_URL }}
        env:
          NUGET_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      # setup-dotnet supports configuring a NuGet source and auth for GitHub Packages. [3](https://jfrog.com/help/r/jfrog-artifactory-documentation/nuget-semver-2.0-package-support)

      - name: Compute version (stable on tag; prerelease otherwise)
        id: version
        shell: pwsh
        run: |
          $ref = "${{ github.ref }}"

          if ($ref -like "refs/tags/v*") {
            $ver = $ref.Substring(11)  # 'refs/tags/v9.1.0' -> '9.1.0'
          } else {
            $major = "${{ inputs.major || github.event.inputs.major || '9' }}"
            $minor = "${{ inputs.minor || github.event.inputs.minor || '1' }}"
            $run   = "${{ github.run_number }}"
            $sha8  = "${{ github.sha }}".Substring(0,8)
            $ver = "$major.$minor.0-alpha.$run+$sha8"  # SemVer 2: prerelease + build metadata
          }

          "version=$ver" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
      # SemVer 2 allows dotted prerelease labels and build metadata via '+', which doesn't affect precedence. [5](https://docs.github.com/en/actions/reference/workflows-and-actions/reusing-workflow-configurations)

      - name: Determine change range
        id: range
        shell: pwsh
        run: |
          $base = "${{ inputs.base || github.event.inputs.base }}"
          $head = "${{ inputs.head || github.event.inputs.head }}"
          $isPush = "${{ github.event_name }}" -eq "push"

          if ([string]::IsNullOrWhiteSpace($base) -or [string]::IsNullOrWhiteSpace($head)) {
            if ($isPush) {
              $base = "${{ github.event.before }}"
              $head = "${{ github.sha }}"
            } else {
              $head = (git rev-parse HEAD).Trim()
              $base = (git rev-parse HEAD~1).Trim()
            }
          }

          if ([string]::IsNullOrWhiteSpace($base) -or $base -eq "0000000000000000000000000000000000000000") {
            $base = (git rev-list --max-parents=0 HEAD | Select-Object -First 1).Trim()
          }

          "base=$base" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "head=$head" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
      # On push events GitHub exposes 'before' as the previous commit SHA; we use that for change detection. [6](https://github.com/orgs/community/discussions/23107)

      - name: Select projects to pack
        id: projects
        shell: pwsh
        run: |
          $mode = "${{ inputs.mode || github.event.inputs.mode || 'changed' }}"
          $glob = "${{ inputs.pack_glob || github.event.inputs.pack_glob || '**/*.csproj' }}"
          $base = "${{ steps.range.outputs.base }}"
          $head = "${{ steps.range.outputs.head }}"

          $changed = (git diff --name-only $base $head) | Where-Object { $_ -ne '' }
          $allTrigger = $false
          foreach ($p in @('Directory.Build.props','Directory.Build.targets','global.json','NuGet.Config','nuget.config')) {
            if ($changed -contains $p -or ($changed | Where-Object { $_ -like "*$p" })) { $allTrigger = $true }
          }

          $candidates = Get-ChildItem -Recurse -Include $glob -File | ForEach-Object { $_.FullName }

          $selected = New-Object System.Collections.Generic.List[string]
          if ($mode -eq 'all' -or $allTrigger -or -not $changed) {
            $selected.AddRange($candidates)
          } else {
            foreach ($proj in $candidates) {
              $projPath = (Resolve-Path $proj).Path
              $projDir  = Split-Path $projPath -Parent
              $projectChanged = $false
              foreach ($f in $changed) {
                $full = (Join-Path (Get-Location) $f)
                if ($full -like "$projDir*") { $projectChanged = $true; break }
              }
              if ($projectChanged) { $selected.Add($projPath) }
            }
          }

          $selected = $selected | Sort-Object -Unique

          if ($selected.Count -eq 0) {
            Write-Host "No packable projects selected."
          } else {
            Write-Host "Projects to pack:"
            $selected | ForEach-Object { Write-Host " - $_" }
          }

          "list<<EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          ($selected -join "`n") | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "count=$($selected.Count)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Restore
        if: steps.projects.outputs.count != '0'
        shell: pwsh
        run: |
          $projects = @('${{ steps.projects.outputs.list }}'.Split("`n"))
          foreach ($p in $projects) {
            if (Test-Path $p) { dotnet restore "$p" }
          }

      - name: Build
        if: steps.projects.outputs.count != '0'
        shell: pwsh
        run: |
          $projects = @('${{ steps.projects.outputs.list }}'.Split("`n"))
          foreach ($p in $projects) {
            if (Test-Path $p) { dotnet build "$p" -c Release --no-restore }
          }

      - name: Pack (per project)
        if: steps.projects.outputs.count != '0'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path artifacts | Out-Null
          $ver = "${{ steps.version.outputs.version }}"
          $projects = @('${{ steps.projects.outputs.list }}'.Split("`n"))
          foreach ($p in $projects) {
            if (Test-Path $p) {
              dotnet pack "$p" -c Release --no-build -o artifacts -p:Version=$ver
            }
          }

      - name: List artifacts
        if: steps.projects.outputs.count != '0'
        shell: pwsh
        run: dir artifacts -Force

      - name: Push packages to GitHub Packages
        if: steps.projects.outputs.count != '0'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Get-ChildItem -Path "artifacts" -Filter *.nupkg | ForEach-Object {
            Write-Host "Pushing $($_.FullName)"
            dotnet nuget push "$($_.FullName)" `
              --skip-duplicate `
              --api-key $env:GITHUB_TOKEN `
              --source "${{ env.NUGET_SOURCE_URL }}"
          }
      # Publishing to GitHub Packages' NuGet feed is supported in Actions with GITHUB_TOKEN. [4](https://nicholaschangblog.com/devops/creating-reusable-workflow-using-github-actions/)